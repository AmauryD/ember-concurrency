<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: task-factory.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: task-factory.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { assert } from '@ember/debug';
import { get } from '@ember/object';
import { addListener } from '@ember/object/events';
import { addObserver } from '@ember/object/observers';
import { scheduleOnce } from '@ember/runloop';
import {
  registerModifier,
  TaskFactory as BaseTaskFactory,
} from './external/task-factory';

import { Task, EncapsulatedTask } from './task';
import { TaskProperty } from './task-properties';
import { TaskGroup } from './task-group';
import EmberScheduler from './scheduler/ember-scheduler';

let handlerCounter = 0;

function registerOnPrototype(
  addListenerOrObserver,
  proto,
  names,
  taskName,
  taskMethod,
  once
) {
  if (names &amp;&amp; names.length > 0) {
    for (let i = 0; i &lt; names.length; ++i) {
      let name = names[i];

      let handlerName = `__ember_concurrency_handler_${handlerCounter++}`;
      proto[handlerName] = makeTaskCallback(taskName, taskMethod, once);
      addListenerOrObserver(proto, name, null, handlerName);
    }
  }
}

function makeTaskCallback(taskName, method, once) {
  return function () {
    let task = get(this, taskName);

    if (once) {
      scheduleOnce('actions', task, method, ...arguments);
    } else {
      task[method].apply(task, arguments);
    }
  };
}

const ensureArray = (possibleArr) =>
  Array.isArray(possibleArr) ? possibleArr : [possibleArr];

registerModifier('cancelOn', (factory, eventNames) =>
  factory.addCancelEvents(...ensureArray(eventNames))
);
registerModifier('observes', (factory, propertyPaths) =>
  factory.addObserverKeys(...ensureArray(propertyPaths))
);
registerModifier('on', (factory, eventNames) =>
  factory.addPerformEvents(...ensureArray(eventNames))
);

/**
 * Factory used for instantiating Tasks and Task Groups. Mostly for internal
 * use, but exposed via the Task Modifier APIs.
 *
 * @class TaskFactory
 */
export class TaskFactory extends BaseTaskFactory {
  createTask(context) {
    assert(
      `Cannot create task if a task definition is not provided as generator function or encapsulated task.`,
      this.taskDefinition
    );

    let options = this.getTaskOptions(context);

    if (typeof this.taskDefinition === 'object') {
      return new EncapsulatedTask(
        Object.assign({ taskObj: this.taskDefinition }, options)
      );
    } else {
      return new Task(
        Object.assign(
          {
            generatorFactory: (args) =>
              this.taskDefinition.apply(context, args),
          },
          options
        )
      );
    }
  }

  createTaskGroup(context) {
    assert(
      `A task definition is not expected for a task group.`,
      !this.taskDefinition
    );
    let options = this.getTaskOptions(context);

    return new TaskGroup(options);
  }

  addCancelEvents(...cancelEventNames) {
    this._cancelEventNames = this._cancelEventNames || [];
    this._cancelEventNames.push(...cancelEventNames);
    return this;
  }

  addObserverKeys(...keys) {
    this._observes = this._observes || [];
    this._observes.push(...keys);
    return this;
  }

  addPerformEvents(...eventNames) {
    this._eventNames = this._eventNames || [];
    this._eventNames.push(...eventNames);
    return this;
  }

  getModifier(name) {
    let modifier = super.getModifier(name);
    if (!modifier &amp;&amp; typeof TaskProperty.prototype[name] === 'function') {
      // Shim for compatibility with user-defined TaskProperty prototype
      // extensions. To be removed when replaced with proper public API.
      modifier = TaskProperty.prototype[name].bind(this);
    }

    assert(
      `Task option '${name}' is not recognized as a supported option.`,
      modifier
    );

    return modifier;
  }

  getScheduler(schedulerPolicy, stateTrackingEnabled) {
    return new EmberScheduler(schedulerPolicy, stateTrackingEnabled);
  }

  _setupEmberKVO(proto) {
    // TODO: Does this make sense in a post-Ember object world?

    registerOnPrototype(
      addListener,
      proto,
      this._eventNames,
      this.name,
      'perform',
      false
    );
    registerOnPrototype(
      addListener,
      proto,
      this._cancelEventNames,
      this.name,
      'cancelAll',
      false
    );
    registerOnPrototype(
      addObserver,
      proto,
      this._observes,
      this.name,
      'perform',
      true
    );
  }

  // Provided for compatibility with ember-concurrency TaskProperty extension
  // methods
  get taskFn() {
    return this.taskDefinition;
  }

  set taskFn(fn) {
    this.setTaskDefinition(fn);
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Task.html">Task</a></li><li><a href="Taskable.html">Taskable</a></li><li><a href="TaskFactory.html">TaskFactory</a></li><li><a href="TaskInstance.html">TaskInstance</a></li><li><a href="TaskProperty.html">TaskProperty</a></li><li><a href="Yieldable.html">Yieldable</a></li><li><a href="YieldableState.html">YieldableState</a></li></ul><h3>Global</h3><ul><li><a href="global.html#all">all</a></li><li><a href="global.html#allSettled">allSettled</a></li><li><a href="global.html#animationFrame">animationFrame</a></li><li><a href="global.html#didCancel">didCancel</a></li><li><a href="global.html#dropTask">dropTask</a></li><li><a href="global.html#dropTaskGroup">dropTaskGroup</a></li><li><a href="global.html#enqueueTask">enqueueTask</a></li><li><a href="global.html#enqueueTaskGroup">enqueueTaskGroup</a></li><li><a href="global.html#forever">forever</a></li><li><a href="global.html#getModifier">getModifier</a></li><li><a href="global.html#hash">hash</a></li><li><a href="global.html#hashSettled">hashSettled</a></li><li><a href="global.html#hasModifier">hasModifier</a></li><li><a href="global.html#keepLatestTask">keepLatestTask</a></li><li><a href="global.html#keepLatestTaskGroup">keepLatestTaskGroup</a></li><li><a href="global.html#race">race</a></li><li><a href="global.html#rawTimeout">rawTimeout</a></li><li><a href="global.html#registerModifier">registerModifier</a></li><li><a href="global.html#restartableTask">restartableTask</a></li><li><a href="global.html#restartableTaskGroup">restartableTaskGroup</a></li><li><a href="global.html#task">task</a></li><li><a href="global.html#taskGroup">taskGroup</a></li><li><a href="global.html#timeout">timeout</a></li><li><a href="global.html#waitForEvent">waitForEvent</a></li><li><a href="global.html#waitForProperty">waitForProperty</a></li><li><a href="global.html#waitForQueue">waitForQueue</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Fri Oct 15 2021 17:43:55 GMT-0500 (Central Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
